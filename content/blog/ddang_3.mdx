---
title: "ê°•ì•„ì§€ ì‚°ì±… ì•± DDang êµ¬í˜„: í•µì‹¬ê¸°ëŠ¥ êµ¬í˜„ê³¼ ì„±ëŠ¥ ìµœì í™”"
date: "2024-11-26"
description: "ì‹¤ì‹œê°„ ìœ„ì¹˜ ì¶”ì  ì•±ì„ ê°œë°œí•˜ë©´ì„œ ê²ªì€ ì„±ëŠ¥ ìµœì í™” ì—¬ì •ì„ ê³µìœ í•©ë‹ˆë‹¤."
tags: ["React", "OpenLayers", "ì„±ëŠ¥ ìµœì í™”", "ìœ„ì¹˜ê¸°ë°˜ì„œë¹„ìŠ¤"]
category: "DDang"
coverImage: "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&auto=format&fit=crop&q=80"
isFeatured: false
---


ì˜¤ëŠ˜ì€ ë°˜ë ¤ë™ë¬¼ ì‚°ì±… ì•±ì„ ê°œë°œí•˜ë©´ì„œ ê²ªì—ˆë˜ ìœ„ì¹˜ ê¸°ë°˜ ì„œë¹„ìŠ¤ì˜ ì„±ëŠ¥ ìµœì í™” ê²½í—˜ì„ ê³µìœ í•˜ë ¤ê³  í•©ë‹ˆë‹¤.
ì‹¤ì‹œê°„ìœ¼ë¡œ ì‚¬ìš©ìì˜ ìœ„ì¹˜ë¥¼ ì¶”ì í•˜ê³  ê²½ë¡œë¥¼ ê·¸ë¦¬ëŠ” ê³¼ì •ì—ì„œ ë§ˆì£¼ì¹œ ë‹¤ì–‘í•œ ë¬¸ì œë“¤ê³¼ í•´ê²° ë°©ë²•ì„ ì†Œê°œí•´ë“œë¦´ê²Œìš”.

## í”„ë¡œì íŠ¸ ì†Œê°œ ğŸ•

ìš°ë¦¬ íŒ€ì´ ê°œë°œí•œ ì•±ì€ ë°˜ë ¤ë™ë¬¼ ì‚°ì±… ê²½ë¡œë¥¼ ê¸°ë¡í•˜ê³ , ë‹¤ë¥¸ ë°˜ë ¤ë™ë¬¼ ë³´í˜¸ìë“¤ê³¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë§Œë‚  ìˆ˜ ìˆëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
OpenLayersë¥¼ ì‚¬ìš©í•´ ì§€ë„ë¥¼ êµ¬í˜„í–ˆê³ , Reactì™€ TypeScriptë¡œ ê°œë°œí–ˆìŠµë‹ˆë‹¤.

## ì£¼ìš” ë„ì „ ê³¼ì œë“¤ ğŸ¯

### 1. ìœ„ì¹˜ ë°ì´í„°ì˜ ì •í™•ë„ í™•ë³´

ì²« ë²ˆì§¸ ë„ì „ ê³¼ì œëŠ” ì •í™•í•œ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì–»ëŠ” ê²ƒì´ì—ˆìŠµë‹ˆë‹¤.

```typescript
// ìœ„ì¹˜ ë°ì´í„° ì •í™•ë„ í•„í„°ë§
const filterPosition = (position: GeolocationPosition): boolean => {
	const isAccurate = position.coords.accuracy <= MIN_ACCURACY;

	// ë„ë¡œ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
	// ì˜ˆ: ì£¼ìš” ë„ë¡œì™€ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ í•„í„°ë§

	return isAccurate;
};
```

ìœ„ì¹˜ ë°ì´í„° í•„í„°ë§ì€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤:

#### 1.1 MIN_ACCURACY ê¸°ì¤€ê°’ ì„¤ì •

- 30më¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•œ ì´ìœ :
  - ì¼ë°˜ì ì¸ ìŠ¤ë§ˆíŠ¸í° GPS ì˜¤ì°¨ ë²”ìœ„(10-50m) ê³ ë ¤
  - ë„ì‹¬ ì§€ì—­ì—ì„œì˜ ì‹¤ì œ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë°˜ì˜
  - ë°°í„°ë¦¬ ì†Œëª¨ì™€ ì •í™•ë„ì˜ ìµœì  ê· í˜•ì 

#### 1.2 ì •í™•ë„ ê²€ì¦ ë¡œì§

- **position.coords.accuracy** ê°’ í™œìš©
- ë‚®ì€ ì •í™•ë„ì˜ ë°ì´í„° ìë™ í•„í„°ë§
- ì‹¤ë‚´/ì§€í•˜ ë“± GPS ì‹ í˜¸ê°€ ì•½í•œ í™˜ê²½ ëŒ€ì‘

### 2. ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ìµœì í™”

```typescript
// API ìš”ì²­ ì¡°ê±´ì„ ë§Œì¡±í•  ë•Œë§Œ ì¢Œí‘œ ì €ì¥ ë° ê²½ë¡œ ê³„ì‚°
if (shouldCallApi(newPosition)) {
	accumulatedPositionsRef.current.push(newPosition);
	addWalkLocationMarker(coordinates);

	if (accumulatedPositionsRef.current.length >= 2) {
		const lastTwoPositions = accumulatedPositionsRef.current.slice(-2);
		calculateWalkingDistance(lastTwoPositions);
	}

	lastApiCallTimeRef.current = Date.now();
}

updateEstimatedDistance();
```

#### 2.1 ìœ„ì¹˜ ë°ì´í„° ìˆ˜ì§‘ ìµœì í™”ë¥¼ ìœ„í•´:

- shouldCallApi ì¡°ê±´ ê²€ì‚¬
  - ìµœì†Œ ì´ë™ ê±°ë¦¬ í™•ì¸
  - ì‹œê°„ ê°„ê²© ì²´í¬
  - ë¶ˆí•„ìš”í•œ API í˜¸ì¶œ ë°©ì§€
- ìœ„ì¹˜ ë°ì´í„° ëˆ„ì  ê´€ë¦¬
  - accumulatedPositionsRef í™œìš©
  - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°
  - ì‹¤ì‹œê°„ ê±°ë¦¬ ê³„ì‚° ì§€ì›

### 3. ì‹¤ì‹œê°„ ê±°ë¦¬ ê³„ì‚°

```tyscript
  // ì§ì„  ê±°ë¦¬ë¡œ ì¶”ì •ì¹˜ ì—…ë°ì´íŠ¸
  const updateEstimatedDistance = () => {
    const positions = accumulatedPositionsRef.current
    if (positions.length < 2) return

    let totalDistance = walkDistance // ì´ì „ê¹Œì§€ì˜ ì‹¤ì œ ê±°ë¦¬

    // ë§ˆì§€ë§‰ API í˜¸ì¶œ ì´í›„ì˜ ê±°ë¦¬ë¥¼ ì§ê±°ë¦¬ë¡œ ê³„ì‚°
    for (let i = 1; i < positions.length; i++) {
      const distance = calculateDirectDistance(
        positions[i - 1].lat,
        positions[i - 1].lng,
        positions[i].lat,
        positions[i].lng
      )
      totalDistance += distance
    }

    setEstimatedDistance(totalDistance)
  }
```

#### 3.1 í•˜ì´ë¸Œë¦¬ë“œ ê±°ë¦¬ ê³„ì‚° ì‹œìŠ¤í…œ:

ì‚¬ìš©ìì˜ ì´ë™ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê¸° ìœ„í•´ í•˜ì´ë¸Œë¦¬ë“œ ê±°ë¦¬ ê³„ì‚° ì‹œìŠ¤í…œì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

OpenRoute Service APIë¥¼ í™œìš©í•´ ì‹¤ì œ ë„ë¡œ ê¸°ë°˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê³ , APIê°€ ì‘ë‹µí•˜ì§€ ì•Šì„ ë•ŒëŠ” ì§ì„  ê±°ë¦¬ë¥¼ ê³„ì‚°í•´ ì‹¤ì‹œê°„ ê±°ë¦¬ë¥¼ ì¶”ì •í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.

[OpenRoute Service ë¡œì»¬ì— êµ¬í˜„í•˜ê¸°](https://ruehan.org/blog/ddang_2/)ì—ì„œ ìì„¸í•œ ë‚´ìš©ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
const calculateDirectDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
	const R = 6371e3; // ì§€êµ¬ì˜ ë°˜ì§€ë¦„ (ë¯¸í„°)
	const Ï†1 = (lat1 * Math.PI) / 180;
	const Ï†2 = (lat2 * Math.PI) / 180;
	const Î”Ï† = ((lat2 - lat1) * Math.PI) / 180;
	const Î”Î» = ((lon2 - lon1) * Math.PI) / 180;

	const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
	const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

	return R * c; // ë¯¸í„° ë‹¨ìœ„ ê±°ë¦¬ ë°˜í™˜
};
```

- ì§ì„  ê±°ë¦¬ ê³„ì‚°
  - Haversine Formula í™œìš©
  - ì‹¤ì‹œê°„ ê±°ë¦¬ ì¶”ì •
  - API ì‘ë‹µ ëŒ€ê¸° ì‹œ ì„ì‹œ ê°’ ì œê³µ

```typescript
const calculateWalkingDistance = async (positions: { lat: number; lng: number }[]) => {
	if (positions.length < 2) return;

	try {
		const coordinates = positions.map((pos) => [pos.lng, pos.lat]);

		const response = await axios.post(ORS_API_URL, {
			coordinates: coordinates,
		});

		if (!response.data.features?.[0]?.properties?.segments?.[0]?.distance) {
			console.log("ìœ íš¨í•œ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
			return;
		}

		// ìƒˆë¡œìš´ êµ¬ê°„ì˜ ê±°ë¦¬ë¥¼ ëˆ„ì 
		const segmentDistance = response.data.features[0].properties.summary.distance;
		setWalkDistance((prev) => prev + segmentDistance);

		// ìƒˆ ê²½ë¡œ êµ¬ê°„ ê·¸ë¦¬ê¸°
		const routeCoords = response.data.features[0].geometry.coordinates.map((coord: number[]) => fromLonLat(coord));

		// ì²« ë²ˆì§¸ ê²½ë¡œê°€ ì•„ë‹Œ ê²½ìš° append ëª¨ë“œë¡œ ê·¸ë¦¬ê¸°
		const isFirstRoute = routeSourceRef.current.getFeatures().length === 0;
		drawRoute(routeCoords, !isFirstRoute);

		lastApiCallTimeRef.current = Date.now();
	} catch (error) {
		console.error("ê±°ë¦¬ ê³„ì‚° ì˜¤ë¥˜:", error);
		updateEstimatedDistance();
	}
};
```

- ì‹¤ì œ ë„ë¡œ ê¸°ë°˜ ê±°ë¦¬ ê³„ì‚°
  - OpenRoute Service API í™œìš©
  - ì‹¤ì œ ë„ë¡œ ê²½ë¡œ ë°˜ì˜
  - ì •í™•í•œ ì´ë™ ê±°ë¦¬ ì¸¡ì •

### 4. ê²½ë¡œ ì‹œê°í™”

```typescript
const drawRoute = (coordinates: number[][], append: boolean = false) => {
	const routeStyle = new Style({
		stroke: new Stroke({
			color: "#FF6B6B", // ê²½ë¡œ ìƒ‰ìƒ ë³€ê²½
			width: 5, // ê²½ë¡œ ë‘ê»˜ ì¦ê°€
			lineCap: "round", // ê²½ë¡œ ëë¶€ë¶„ì„ ë‘¥ê¸€ê²Œ
			lineJoin: "round", // ê²½ë¡œ ì—°ê²°ë¶€ë¶„ì„ ë‘¥ê¸€ê²Œ
		}),
	});

	if (!append) {
		const lineString = new LineString(coordinates);
		const feature = new Feature({
			geometry: lineString,
		});
		feature.setStyle(routeStyle);
		routeSourceRef.current.clear();
		routeSourceRef.current.addFeature(feature);
	} else {
		const existingFeature = routeSourceRef.current.getFeatures()[0];
		if (existingFeature) {
			const existingLine = existingFeature.getGeometry() as LineString;
			const existingCoords = existingLine.getCoordinates();
			existingLine.setCoordinates([...existingCoords, ...coordinates.slice(1)]);
			existingFeature.setStyle(routeStyle);
		}
	}
};
```

```typescript
const addWalkLocationMarker = (coordinates: number[]) => {
	const marker = new Feature({
		geometry: new Point(coordinates),
	});

	const markerStyle = new Style({
		image: new Circle({
			radius: 4,
			fill: new Fill({ color: "#4CAF50" }),
			stroke: new Stroke({
				color: "#ffffff",
				width: 2,
			}),
		}),
	});

	marker.setStyle(markerStyle);
	vectorSourceRef.current.addFeature(marker);
};
```

- ì‚¬ìš©ì ê²½í—˜ì„ ê³ ë ¤í•œ ì‹œê°í™”:
  - ìŠ¤íƒ€ì¼ë§ ìµœì í™”
  - ê°€ì‹œì„± ë†’ì€ ìƒ‰ìƒ ì„ íƒ
  - ë¶€ë“œëŸ¬ìš´ ì„  ì²˜ë¦¬
  - ì§ê´€ì ì¸ ì‹œê°ì  í‘œí˜„
- ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
  - ë²¡í„° ë ˆì´ì–´ í™œìš©
  - ë©”ëª¨ë¦¬ íš¨ìœ¨ì  êµ¬í˜„
  - ë Œë”ë§ ìµœì í™”

### 5. ë‚˜ì¹¨ë°˜ ê¸°ëŠ¥ êµ¬í˜„

ì•„ë˜ì—ì„œ ì§„í–‰í•  **ì§€ë„ íšŒì „ ë° í™”ë©´ ë°©í–¥ ì²˜ë¦¬**ë¥¼ ìœ„í•œ ë‚˜ì¹¨ë°˜ ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```typescript
const handleCompassPermission = async () => {
	if (DeviceOrientationEvent && typeof (DeviceOrientationEvent as any).requestPermission === "function") {
		try {
			const response = await (DeviceOrientationEvent as any).requestPermission();
			setHasCompassPermission(response === "granted");
			if (response === "granted") {
				setAutoRotate(true);
				rotateMap(lastHeadingRef.current);
			}
		} catch (error) {
			console.error("ë‚˜ì¹¨ë°˜ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨:", error);
		}
	} else {
		setHasCompassPermission(true);
		setAutoRotate(true);
	}
};
```

ë‚˜ì¹¨ë°˜ ê¸°ëŠ¥ì˜ ì£¼ìš” íŠ¹ì§•:

- iOS/Android í”Œë«í¼ ëŒ€ì‘
- ê¶Œí•œ ìš”ì²­ ì²˜ë¦¬
- ìë™ íšŒì „ ê¸°ëŠ¥ êµ¬í˜„

### 6. ì§€ë„ íšŒì „ ë° í™”ë©´ ë°©í–¥ ì²˜ë¦¬

```typescript
const rotateMap = (heading: number) => {
	if (!mapRef.current) return;

	const view = mapRef.current.getView();
	const rotation = (-heading * Math.PI) / 180;

	view.animate({
		rotation: rotation,
		duration: 250,
		easing: easeOut,
	});
};
```

ì§€ë„ íšŒì „ ê¸°ëŠ¥ì˜ íŠ¹ì§•:

- ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
- ì„±ëŠ¥ ìµœì í™”ëœ íšŒì „ ì²˜ë¦¬
- ì§ê´€ì ì¸ ë°©í–¥ í‘œì‹œ